<!DOCTYPE html>
<!--
  NC File Converter v1.0.0
  
  A browser-based tool for converting numerical control (NC) files between metric (mm) and imperial (inch) units.
  Developed by Lasercomb GmbH ( Aaron Delia aardel@gmail.com )
  
  Features:
  - Convert G-code files between millimeters and inches
  - Auto-detect units in your NC files
  - Customizable token conversion (X, Y, Z, I, J, etc.)
  - H-Function mapping for different machine operations
  - Live preview with syntax highlighting
  - DXF export capability
  - Dark mode support
  - Offline use (runs entirely in browser)
  
  Copyright (c) 2025 Lasercomb GmbH
  This software may be freely distributed in its original, unmodified form.
  See the LICENSE file for complete terms.
  
  GitHub: https://github.com/aardel/nc-file-converter
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NC File Converter</title>
  <style>
    /* Modern Design Variables */
    :root {
      --bg-color: #f5f7fa;
      --text-color: #333;
      --primary-color: #4361ee;
      --primary-hover: #3a56d4;
      --secondary-color: #4cc9f0;
      --success-color: #06d6a0;
      --warning-color: #ffd166;
      --danger-color: #ef476f;
      --gray-100: #f8f9fa;
      --gray-200: #e9ecef;
      --gray-300: #dee2e6;
      --gray-400: #ced4da;
      --gray-500: #adb5bd;
      --gray-600: #6c757d;
      --gray-700: #495057;
      --gray-800: #343a40;
      --gray-900: #212529;
      
      /* Layout */
      --border-radius-sm: 4px;
      --border-radius: 8px;
      --border-radius-lg: 12px;
      --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
      --shadow: 0 4px 6px rgba(0,0,0,0.1);
      --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);
      --transition: all 0.2s ease-in-out;
      
      /* Font settings */
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      
      /* Space scale */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 16px;
      --space-4: 24px;
      --space-5: 32px;
      --space-6: 48px;
    }

    /* Dark mode variables */
    .dark-mode {
      --bg-color: #121212;
      --text-color: #e9ecef;
      --primary-color: #4cc9f0;
      --primary-hover: #70d6f7;
      --gray-100: #212529;
      --gray-200: #343a40;
      --gray-300: #495057;
      --gray-400: #6c757d;
      --gray-500: #adb5bd;
      --gray-600: #ced4da;
      --gray-700: #dee2e6;
      --gray-800: #e9ecef;
      --gray-900: #f8f9fa;
      
      /* Specific overrides for dark mode */
      --shadow-sm: 0 2px 4px rgba(0,0,0,0.3);
      --shadow: 0 4px 6px rgba(0,0,0,0.4);
      --shadow-lg: 0 10px 15px rgba(0,0,0,0.5);
    }
    
    /* Base styles */
    * { 
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      font-family: var(--font-family);
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
      width: 100%;
      max-width: 100%;
      overflow-x: hidden;
      transition: var(--transition);
    }
    
    /* Typography */
    h1, h2, h3, h4, h5, h6 {
      margin-bottom: var(--space-3);
      font-weight: 600;
      line-height: 1.3;
    }
    
    h1 { font-size: 28px; }
    h2 { font-size: 24px; }
    h3 { font-size: 20px; }
    h4 { font-size: 18px; }
    h5 { font-size: 16px; }
    h6 { font-size: 14px; }
    
    p {
      margin-bottom: var(--space-3);
    }
    
    /* Layout components */
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 var(--space-3);
    }
    
    /* Cards and panels */
    .card {
      background-color: var(--gray-100);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      transition: var(--transition);
    }
    
    .card:hover {
      box-shadow: var(--shadow-lg);
    }
    
    .card-header {
      padding: var(--space-3);
      border-bottom: 1px solid var(--gray-300);
      background-color: rgba(0, 0, 0, 0.02);
    }
    
    .card-body {
      padding: var(--space-3);
    }
    
    /* Forms */
    label {
      display: block;
      margin-bottom: var(--space-2);
      font-weight: 500;
      color: var(--gray-700);
    }
    
    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      padding: var(--space-2) var(--space-3);
      border: 1px solid var(--gray-400);
      border-radius: var(--border-radius-sm);
      background-color: var(--gray-100);
      color: var(--text-color);
      font-family: var(--font-family);
      font-size: 16px;
      transition: var(--transition);
    }
    
    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.15);
    }
    
    .form-group {
      margin-bottom: var(--space-3);
    }
    
    /* Buttons */
    button,
    .btn {
      display: inline-block;
      padding: var(--space-2) var(--space-3);
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius-sm);
      font-family: var(--font-family);
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      text-align: center;
    }
    
    button:hover,
    .btn:hover {
      background-color: var(--primary-hover);
      transform: translateY(-1px);
    }
    
    button:active,
    .btn:active {
      transform: translateY(0);
    }
    
    button:disabled,
    .btn:disabled {
      background-color: var(--gray-500);
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-secondary {
      background-color: var(--gray-500);
    }
    
    .btn-secondary:hover {
      background-color: var(--gray-600);
    }
    
    .btn-danger {
      background-color: var(--danger-color);
    }
    
    .btn-danger:hover {
      background-color: #d64161;
    }
    
    .btn-sm {
      padding: var(--space-1) var(--space-2);
      font-size: 14px;
    }
    
    /* Header styles */
    .header {
      background-color: var(--gray-100);
      padding: var(--space-4) 0;
      box-shadow: var(--shadow);
      position: relative;
      z-index: 10;
      text-align: center;
    }
    
    .header h1 {
      margin-bottom: var(--space-1);
      color: var(--primary-color);
    }
    
    .header p {
      margin-bottom: var(--space-3);
      color: var(--gray-600);
    }
    
    /* File upload area */
    .file-area {
      border: 2px dashed var(--primary-color);
      border-radius: var(--border-radius);
      padding: var (--space-4);
      text-align: center;
      background-color: rgba(67, 97, 238, 0.05);
      cursor: pointer;
      max-width: 500px;
      margin: 0 auto;
      transition: var(--transition);
    }
    
    .file-area:hover, .file-area.hover {
      background-color: rgba(67, 97, 238, 0.1);
      border-color: var(--primary-hover);
    }
    
    .file-area:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.25);
    }
    
    .file-icon {
      font-size: 48px;
      margin-bottom: var(--space-2);
      color: var(--primary-color);
      transition: var(--transition);
    }
    
    .file-area:hover .file-icon {
      transform: scale(1.1);
    }
    
    .file-info {
      text-align: center;
      margin-top: var(--space-3);
      background-color: var(--gray-100);
      padding: var(--space-3);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-sm);
    }
    
    /* Tabs */
    .tabs {
      width: 100%;
      margin-top: var(--space-4);
      background-color: var(--gray-100);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    
    .tab-headers {
      display: flex;
      border-bottom: 1px solid var(--gray-300);
      overflow-x: auto;
      background-color: var(--gray-200);
    }
    
    .tab-header {
      padding: var(--space-3);
      cursor: pointer;
      border-bottom: 3px solid transparent;
      font-weight: 500;
      white-space: nowrap;
      transition: var(--transition);
    }
    
    .tab-header:hover {
      color: var(--primary-color);
      background-color: rgba(67, 97, 238, 0.05);
    }
    
    .tab-header.active {
      border-bottom: 3px solid var(--primary-color);
      color: var(--primary-color);
      background-color: var(--gray-100);
    }
    
    .tab-header:focus {
      outline: none;
      box-shadow: inset 0 0 0 3px rgba(67, 97, 238, 0.25);
    }
    
    .tab-content {
      padding: var(--space-4);
    }
    
    /* Preview panels */
    .preview-container {
      display: flex;
      gap: var(--space-3);
      flex-wrap: wrap;
    }
    
    .preview-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 300px;
    }
    
    .preview-panel strong {
      margin-bottom: var(--space-2);
      display: block;
    }
    
    .preview {
      font-family: var(--font-mono);
      white-space: pre-wrap;
      background-color: var(--gray-100);
      border: 1px solid var(--gray-300);
      border-radius: var(--border-radius-sm);
      padding: var(--space-3);
      max-height: 600px;
      overflow-y: auto;
      box-shadow: inset var(--shadow-sm);
    }
    
    /* Token styling */
    .highlight-token {
      background-color: rgba(67, 97, 238, 0.15);
      color: var(--primary-color);
      border-radius: var(--border-radius-sm);
      padding: 0 2px;
      font-weight: bold;
    }
    
    .dark-mode .highlight-token {
      background-color: rgba(76, 201, 240, 0.15);
      color: var(--primary-color);
    }
    
    /* H Function highlighting */
    .highlight-h-function {
      background-color: rgba(239, 68, 68, 0.15);
      color: var(--danger-color);
      border-radius: var(--border-radius-sm);
      padding: 0 2px;
      font-weight: bold;
    }
    
    .dark-mode .highlight-h-function {
      background-color: rgba(239, 68, 68, 0.2);
      color: #ff6b6b;
    }
    
    /* Search match highlighting */
    .search-match {
      background-color: rgba(255, 209, 102, 0.3);
      border-radius: var(--border-radius-sm);
    }
    
    .search-match.current {
      background-color: rgba(255, 209, 102, 0.6);
      outline: 2px solid var(--warning-color);
    }
    
    /* H Function Mapping */
    .hmap-row {
      display: flex;
      gap: var(--space-3);
      margin-bottom: var(--space-3);
      align-items: center;
      padding: var(--space-2);
      border-radius: var(--border-radius-sm);
      background-color: var(--gray-100);
      transition: var(--transition);
    }
    
    .hmap-row:hover {
      background-color: var(--gray-200);
    }
    
    .hmap-row span {
      flex: 1;
      font-weight: 500;
    }
    
    .hmap-row select {
      flex: 2;
      padding: var(--space-2);
    }
    
    /* Toast notification */
    .toast {
      position: fixed;
      bottom: var(--space-4);
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--primary-color);
      color: white;
      padding: var(--space-3) var(--space-4);
      border-radius: var(--border-radius);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      font-weight: 500;
    }
    
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(-10px);
    }
    
    .toast.error {
      background-color: var(--danger-color);
    }
    
    .toast.warning {
      background-color: var(--warning-color);
      color: var(--gray-900);
    }
    
    .toast.success {
      background-color: var(--success-color);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .preview-container {
        flex-direction: column;
      }
      
      .preview-panel {
        min-width: 100%;
      }
      
      .tab-header {
        padding: var(--space-2);
        font-size: 14px;
      }
    }
    
    /* Checkbox and radio styling */
    .checkbox-option, .radio-option {
      display: flex;
      align-items: center;
      margin-bottom: var (--space-2);
      cursor: pointer;
    }
    
    .checkbox-option input[type="checkbox"],
    .radio-option input[type="radio"] {
      margin-right: var(--space-2);
      cursor: pointer;
    }
    
    /* Animation keyframes */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    /* Apply animations */
    .file-info, .tabs {
      animation: fadeIn 0.5s ease-out;
    }
    
    .tab-content {
      animation: slideUp 0.3s ease-out;
    }
  </style>
</head>
<body>
  <!-- Header Section -->
  <header class="header">
    <div class="container">
      <h1>Lasercomb GmbH</h1>
      <p>NC Files Unit Converter v1</p>
      <div class="file-area" id="fileArea" tabindex="0" role="button" aria-label="Select or drop NC file">
        <div class="file-icon">📁</div>
        <p>Click or drop your NC file here</p>
        <input type="file" id="fileInput" style="display:none;">
      </div>
      <div class="file-info" id="fileInfo" style="display:none;">
        <p><strong>File:</strong> <span id="fileName">-</span></p>
        <p><strong>Size:</strong> <span id="fileSize">-</span></p>
        <p><strong>Detected Unit:</strong> <span id="detectedUnit">-</span></p>
      </div>
    </div>
  </header>
  <!-- Main Content -->
  <main class="container">
    <div class="tabs">
      <div class="tab-headers">
        <div class="tab-header active" data-tab="conversion" tabindex="0" role="button">Conversion</div>
        <div class="tab-header" data-tab="preview" tabindex="0" role="button">Preview</div>
        <div class="tab-header" data-tab="hfunctions" tabindex="0" role="button">H Functions</div>
        <div class="tab-header" data-tab="settings" tabindex="0" role="button">Settings</div>
      </div>
      
      <!-- Conversion Tab -->
      <div class="tab-content" id="conversion-tab">
        <h3>Conversion Settings</h3>
        <p>Select your desired conversion type. The conversion will occur automatically when a file is loaded.</p>
        
        <div class="card">
          <div class="card-body">
            <div class="radio-option">
              <input type="radio" name="conversionType" id="inchToMm" value="inchToMm" checked>
              <label for="inchToMm">Inch to mm</label>
            </div>
            <div class="radio-option">
              <input type="radio" name="conversionType" id="mmToInch" value="mmToInch">
              <label for="mmToInch">mm to Inch</label>
            </div>
            <div class="radio-option">
              <input type="radio" name="conversionType" id="autoDetect" value="autoDetect">
              <label for="autoDetect">Auto Detect</label>
            </div>
          </div>
        </div>
        
        <div class="actions" style="margin-top: var(--space-4); display: flex; gap: var(--space-3);">
          <button id="downloadConvertedBtn" disabled>
            <i class="icon">⬇️</i> Download Converted File
          </button>
          <button id="exportDxfBtn" disabled>
            <i class="icon">📐</i> Export as DXF
          </button>
        </div>
      </div>
      
      <!-- Preview Tab -->
      <div class="tab-content" id="preview-tab" style="display:none;">
        <h3>File Preview</h3>
        <p>Compare the original code with the converted result. <span style="color: var(--primary-color); font-weight: 500;">Blue</span> highlights show converted tokens, <span style="color: var(--danger-color); font-weight: 500;">red</span> highlights show H functions that will be changed.</p>
        
        <!-- NEW: Search Container -->
        <div class="search-container" style="margin-bottom: var(--space-3);">
          <div style="display: flex; gap: var(--space-2); margin-bottom: var(--space-2);">
            <input type="text" id="previewSearchInput" placeholder="Search in preview..." style="flex-grow: 1;">
            <button id="previewSearchBtn">Search</button>
          </div>
          <div style="display: flex; gap: var(--space-2); align-items: center;">
            <button id="prevMatchBtn" class="btn-sm" disabled>Previous</button>
            <button id="nextMatchBtn" class="btn-sm" disabled>Next</button>
            <span id="searchResultsInfo" style="font-size: 14px; color: var(--gray-600);"></span>
            <div class="checkbox-option" style="margin-left: auto; margin-bottom: 0;">
              <input type="checkbox" id="searchCaseSensitive">
              <label for="searchCaseSensitive" style="margin-bottom: 0;">Case sensitive</label>
            </div>
          </div>
        </div>
        
        <div class="preview-container">
          <div class="preview-panel">
            <strong>Original Code:</strong>
            <div class="preview" id="originalPreview">No file loaded.</div>
          </div>
          <div class="preview-panel">
            <strong>Converted Code:</strong>
            <div class="preview" id="convertedPreview">No conversion available.</div>
          </div>
        </div>
      </div>
      
      <!-- H Functions Tab -->
      <div class="tab-content" id="hfunctions-tab" style="display:none;">
        <div class="flex-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: var(--space-4);">
          <div>
            <h3>H Function Mapping</h3>
            <p>Map H functions in your file to alternative functions.</p>
          </div>
          <button id="detectHBtn" class="btn">
            <i class="icon">🔍</i> Detect H Numbers
          </button>
        </div>
        
        <div class="card">
          <div class="card-body" id="hMappingContainer" style="min-height: 100px;">
            <!-- H mapping content will be generated here -->
          </div>
        </div>
        
        <div style="margin-top: var(--space-4);">
          <button id="resetHMappingBtn">Reset H Mappings</button>
        </div>
      </div>
      
      <!-- Settings Tab -->
      <div class="tab-content" id="settings-tab" style="display:none;">
        <h3>Application Settings</h3>
        <p>Customize how the converter behaves.</p>
        
        <!-- Precision Settings Card -->
        <div class="card" style="margin-bottom: var(--space-4);">
          <div class="card-header">
            <h4 style="margin-bottom: 0;">Precision Settings</h4>
          </div>
          <div class="card-body">
            <p>Define the number of decimals for conversion results.</p>
            
            <div class="form-group">
              <label for="mmPrecision">mm Precision (decimals):</label>
              <input type="number" id="mmPrecision" min="0" max="6" value="3">
            </div>
            
            <div class="form-group">
              <label for="inchPrecision">Inch Precision (decimals):</label>
              <input type="number" id="inchPrecision" min="0" max="6" value="4">
            </div>
          </div>
        </div>
        
        <!-- File Formatting Card -->
        <div class="card" style="margin-bottom: var(--space-4);">
          <div class="card-header">
            <h4 style="margin-bottom: 0;">File Formatting</h4>
          </div>
          <div class="card-body">
            <p>Settings affecting file output formatting.</p>
            
            <div class="checkbox-option">
              <input type="checkbox" id="preserveNewlines" checked>
              <label for="preserveNewlines">Preserve original newline format</label>
            </div>
            
            <div class="checkbox-option">
              <input type="checkbox" id="normalizeSpacing">
              <label for="normalizeSpacing">Normalize spacing between tokens and values</label>
            </div>
          </div>
        </div>
        
        <!-- Token Management Card -->
        <div class="card" style="margin-bottom: var (--space-4);">
          <div class="card-header">
            <h4 style="margin-bottom: 0;">Conversion Tokens</h4>
          </div>
          <div class="card-body">
            <p>Define which tokens should be converted (coordinates, dimensions, etc.)</p>
            
            <!-- Token List with scrollable container -->
            <div style="border: 1px solid var(--gray-300); border-radius: var(--border-radius-sm); max-height: 200px; overflow-y: auto; margin-bottom: var(--space-3);">
              <div id="tokenList" style="padding: var(--space-2); min-height: 50px;"></div>
            </div>
            
            <!-- Add Token Form -->
            <div style="display: flex; gap: var(--space-2); margin-bottom: var(--space-3);">
              <input type="text" id="customToken" placeholder="Add custom token (e.g. X, Y, Z, I, J, R)" 
                     style="flex-grow: 1;">
              <button id="addTokenBtn">Add Token</button>
            </div>
            
            <!-- Predefined Common Tokens -->
            <div style="margin-bottom: var(--space-3);">
              <h5>Common Tokens:</h5>
              <div style="display: flex; flex-wrap: wrap; gap: var(--space-2); margin-top: var(--space-2);">
                <button class="quick-token-btn btn-sm" data-token="X">X</button>
                <button class="quick-token-btn btn-sm" data-token="Y">Y</button>
                <button class="quick-token-btn btn-sm" data-token="Z">Z</button>
                <button class="quick-token-btn btn-sm" data-token="I">I</button>
                <button class="quick-token-btn btn-sm" data-token="J">J</button>
                <button class="quick-token-btn btn-sm" data-token="K">K</button>
                <button class="quick-token-btn btn-sm" data-token="R">R</button>
                <button class="quick-token-btn btn-sm" data-token="Radius:">Radius:</button>
                <button class="quick-token-btn btn-sm" data-token="CylDia:">CylDia:</button>
              </div>
            </div>
            
            <!-- Reset Tokens Button -->
            <button id="resetTokensBtn" class="btn-secondary">Reset to Default Tokens</button>
          </div>
        </div>
        
        <!-- NEW: H Function Definitions Management -->
        <div class="card" style="margin-bottom: var(--space-4);">
          <div class="card-header">
            <h4 style="margin-bottom: 0;">H Function Definitions</h4>
          </div>
          <div class="card-body">
            <p>Manage the H function definitions used throughout the application.</p>
            
            <!-- H Functions List -->
            <div style="border: 1px solid var(--gray-300); border-radius: var(--border-radius-sm); max-height: 300px; overflow-y: auto; margin-bottom: var(--space-3);">
              <div id="hFunctionsList" style="padding: var(--space-2); min-height: 50px;"></div>
            </div>
            
            <!-- Add H Function Form -->
            <div style="margin-bottom: var(--space-3);">
              <div class="form-group">
                <label for="newHNumber">H Function Number:</label>
                <div style="display: flex; gap: var(--space-2); align-items: center;">
                  <span style="font-weight: 500;">H</span>
                  <input type="number" id="newHNumber" min="1" style="flex-grow: 1;" placeholder="Enter H number (e.g. 1, 2, 3)">
                </div>
              </div>
              
              <div class="form-group">
                <label for="newHName">Function Name:</label>
                <input type="text" id="newHName" placeholder="Enter function description (e.g. 1 point, 2 points)">
              </div>
              
              <button id="addHFunctionBtn" class="btn">Add H Function</button>
            </div>
            
            <!-- Edit Mode Section (hidden by default) -->
            <div id="editHFunctionSection" style="display: none; margin-bottom: var(--space-3); padding: var(--space-3); background-color: var(--gray-100); border-radius: var(--border-radius-sm);">
              <h5>Edit H Function</h5>
              
              <div class="form-group">
                <label for="editHNumber">H Function Number:</label>
                <div style="display: flex; gap: var(--space-2); align-items: center;">
                  <span style="font-weight: 500;">H</span>
                  <input type="number" id="editHNumber" min="1" style="flex-grow: 1;" disabled>
                </div>
              </div>
              
              <div class="form-group">
                <label for="editHName">Function Name:</label>
                <input type="text" id="editHName">
              </div>
              
              <div style="display: flex; gap: var(--space-2);">
                <button id="saveHFunctionBtn" class="btn">Save Changes</button>
                <button id="cancelEditHFunctionBtn" class="btn-secondary">Cancel</button>
              </div>
            </div>
            
            <button id="resetHFunctionsBtn" class="btn-secondary">Reset to Default H Functions</button>
          </div>
        </div>
        
        <!-- Appearance Settings Card -->
        <div class="card" style="margin-bottom: var(--space-4);">
          <div class="card-header">
            <h4 style="margin-bottom: 0;">Appearance Settings</h4>
          </div>
          <div class="card-body">
            <div class="checkbox-option">
              <input type="checkbox" id="darkModeToggle">
              <label for="darkModeToggle">Dark Mode</label>
            </div>
          </div>
        </div>
        
        <!-- Updates Card -->
        <div class="card" style="margin-bottom: var(--space-4);">
          <div class="card-header">
            <h4 style="margin-bottom: 0;">Updates</h4>
          </div>
          <div class="card-body">
            <p>Current Version: <span id="currentVersion"></span></p>
            <p>Last checked: <span id="lastUpdateCheck">Never</span></p>
            <button id="checkUpdateBtn" class="btn">Check for Updates</button>
            <div id="updateStatus" style="margin-top: var(--space-2);"></div>
          </div>
        </div>
        
        <!-- Reset Settings Card -->
        <div class="card">
          <div class="card-header">
            <h4 style="margin-bottom: 0;">Reset Settings</h4>
          </div>
          <div class="card-body">
            <p>Click below to reset all settings (except H mappings) to default values.</p>
            <button id="resetSettingsBtn" class="btn-danger">Reset to Default Settings</button>
          </div>
        </div>
      </div>
    </div>
  </main>
  
  <!-- Toast notification -->
  <div class="toast" id="toast"></div>
  
  <!-- Token Item Template (for JS reference) -->
  <template id="tokenItemTemplate">
    <div class="token-item" style="display: flex; align-items: center; padding: 8px; background-color: var(--gray-100); margin-bottom: 4px; border-radius: var(--border-radius-sm); border: 1px solid var(--gray-300);">
      <span class="token-name" style="flex-grow: 1; font-weight: 500; font-family: var(--font-mono);"></span>
      <button class="remove-token btn-sm btn-danger" style="padding: 2px 8px;">Remove</button>
    </div>
  </template>
  
  <!-- H Function Definition Item Template (for JS reference) -->
  <template id="hFunctionDefItemTemplate">
    <div class="h-function-def-item" style="display: flex; align-items: center; padding: 8px; background-color: var(--gray-100); margin-bottom: 4px; border-radius: var(--border-radius-sm); border: 1px solid var(--gray-300);">
      <span class="h-number" style="font-weight: 500; font-family: var(--font-mono); min-width: 50px;"></span>
      <span class="h-name" style="flex-grow: 1; margin-left: 10px;"></span>
      <div style="display: flex; gap: 4px;">
        <button class="edit-h-function btn-sm" style="padding: 2px 8px;">Edit</button>
        <button class="remove-h-function btn-sm btn-danger" style="padding: 2px 8px;">Remove</button>
      </div>
    </div>
  </template>
  
  <!-- H Mapping Item Template (for JS reference) -->
  <template id="hMappingItemTemplate">
    <div class="hmap-row">
      <span class="h-original"></span>
      <select class="h-mapping"></select>
      <button class="remove-mapping btn-sm btn-danger">Remove</button>
    </div>
  </template>
  <script>
    /* --- Constants --- */
    const SETTINGS_KEY = "ncConverterSettings";
    const HMAPPING_KEY = "ncHMapping";
    const DEFAULT_TOKENS = ["X", "Y", "I", "J", "R", "Radius:", "CylDia:"];
    const DEFAULT_H_FUNCTIONS = {
      "H1": "1 point",
      "H2": "2 points",
      "H3": "3 points",
      "H4": "4 points",
      "H5": "1.5 points",
      "H11": "1 point/pulse",
      "H12": "2 points/pulse",
      "H13": "3 points/pulse",
      "H14": "4 points/pulse",
      "H15": "1.5 points/pulse",
      "H20": "Fast Engrave",
      "H21": "Fine cut pulse",
      "H22": "Fine cut CW",
      "H25": "2 points bridge",
      "H26": "3 points bridge",
      "H27": "4 points bridge",
      "H33": "Nozzle Engrave",
      "H40": "Groove",
      "H41": "Cut CW",
      "H42": "Pulse_1",
      "H43": "Pulse_2",
      "H44": "Engrave",
      "H100": "Milling Height 1",
      "H101": "Milling Height 2"
    };
    
    /* --- DOM References --- */
    // File handling elements
    const fileArea = document.getElementById("fileArea");
    const fileInput = document.getElementById("fileInput");
    const fileInfo = document.getElementById("fileInfo");
    const fileName = document.getElementById("fileName");
    const fileSize = document.getElementById("fileSize");
    const detectedUnit = document.getElementById("detectedUnit");
    
    // Action buttons
    const downloadConvertedBtn = document.getElementById("downloadConvertedBtn");
    const exportDxfBtn = document.getElementById("exportDxfBtn");
    
    // Tab navigation
    const tabHeaders = document.querySelectorAll(".tab-header");
    const tabContents = document.querySelectorAll(".tab-content");
    
    // Token management
    const tokenList = document.getElementById("tokenList");
    const customToken = document.getElementById("customToken");
    const addTokenBtn = document.getElementById("addTokenBtn");
    const resetTokensBtn = document.getElementById("resetTokensBtn");
    const tokenItemTemplate = document.getElementById("tokenItemTemplate");
    
    // H function mapping
    const detectHBtn = document.getElementById("detectHBtn");
    const hMappingContainer = document.getElementById("hMappingContainer");
    const resetHMappingBtn = document.getElementById("resetHMappingBtn");
    const hMappingItemTemplate = document.getElementById("hMappingItemTemplate");
    
    // H function definition management
    const hFunctionsList = document.getElementById("hFunctionsList");
    const newHNumber = document.getElementById("newHNumber");
    const newHName = document.getElementById("newHName");
    const addHFunctionBtn = document.getElementById("addHFunctionBtn");
    const editHFunctionSection = document.getElementById("editHFunctionSection");
    const editHNumber = document.getElementById("editHNumber");
    const editHName = document.getElementById("editHName");
    const saveHFunctionBtn = document.getElementById("saveHFunctionBtn");
    const cancelEditHFunctionBtn = document.getElementById("cancelEditHFunctionBtn");
    const resetHFunctionsBtn = document.getElementById("resetHFunctionsBtn");
    const hFunctionDefItemTemplate = document.getElementById("hFunctionDefItemTemplate");
    
    // Preview elements
    const originalPreview = document.getElementById("originalPreview");
    const convertedPreview = document.getElementById("convertedPreview");
    
    // Settings elements
    const resetSettingsBtn = document.getElementById("resetSettingsBtn");
    const darkModeToggle = document.getElementById("darkModeToggle");
    
    // Notification
    const toast = document.getElementById("toast");
    
    /* --- State --- */
    let settings = loadSettings();
    let hMapping = loadHMapping();
    let fileContent = "";
    let convertedContent = "";
    let selectedFile = null;
    let finalUnits = "mm";
    let currentlyEditingH = null; // For tracking which H function is being edited
    
    /* --- Settings Management --- */
    function loadSettings() {
      const stored = localStorage.getItem(SETTINGS_KEY);
      if (stored) {
        try { 
          return JSON.parse(stored); 
        } catch (e) { 
          console.error("Error parsing stored settings:", e);
          return getDefaultSettings(); 
        }
      }
      return getDefaultSettings();
    }
    
    function getDefaultSettings() {
      return {
        conversionType: "inchToMm",
        mmPrecision: "3",
        inchPrecision: "4",
        preserveNewlines: true,
        normalizeSpacing: false,
        darkMode: false,
        autoRedetectH: true,
        tokens: [...DEFAULT_TOKENS],
        hFunctions: {...DEFAULT_H_FUNCTIONS} // Added H functions to settings
      };
    }
    
    function saveSettings(settings) {
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      } catch (e) {
        console.error("Error saving settings:", e);
        showToast("Failed to save settings", "error");
      }
    }
    
    function loadHMapping() {
      const stored = localStorage.getItem(HMAPPING_KEY);
      if (stored) {
        try { 
          const parsed = JSON.parse(stored);
          return Array.isArray(parsed) ? parsed : [];
        } catch (e) { 
          console.error("Error parsing H mappings:", e);
          return []; 
        }
      }
      return [];
    }
    
    function saveHMapping(mapping) {
      try {
        localStorage.setItem(HMAPPING_KEY, JSON.stringify(mapping));
      } catch (e) {
        console.error("Error saving H mappings:", e);
        showToast("Failed to save H mappings", "error");
      }
    }
    
    function updateStoredSettings() {
      // Conversion settings
      settings.conversionType = document.querySelector('input[name="conversionType"]:checked').value;
      settings.mmPrecision = document.getElementById("mmPrecision").value;
      settings.inchPrecision = document.getElementById("inchPrecision").value;
      
      // Formatting settings
      settings.preserveNewlines = document.getElementById("preserveNewlines").checked;
      settings.normalizeSpacing = document.getElementById("normalizeSpacing").checked;
      settings.darkMode = document.getElementById("darkModeToggle").checked;
      
      // Auto-redetect setting
      const autoRedetectCheckbox = document.getElementById("autoRedetectH");
      if (autoRedetectCheckbox) {
        settings.autoRedetectH = autoRedetectCheckbox.checked;
      }
      
      // Token settings
      if (tokenList) {
        const tokenElems = tokenList.querySelectorAll('.token-item .token-name');
        settings.tokens = Array.from(tokenElems).map(el => el.textContent);
      }
      
      // H Functions are already updated in the add/edit/delete functions
      
      saveSettings(settings);
    }
    
    function resetSettings() {
      settings = getDefaultSettings();
      saveSettings(settings);
      applySettings();
      showToast("Settings have been reset to default", "success");
      updateConversion();
    }
    
    function applySettings() {
      // Apply conversion type
      if (settings.conversionType) {
        const radio = document.querySelector(`input[name="conversionType"][value="${settings.conversionType}"]`);
        if (radio) radio.checked = true;
      }
      
      // Apply precision settings
      if (settings.mmPrecision) document.getElementById("mmPrecision").value = settings.mmPrecision;
      if (settings.inchPrecision) document.getElementById("inchPrecision").value = settings.inchPrecision;
      
      // Apply formatting settings
      if (typeof settings.preserveNewlines === "boolean") {
        document.getElementById("preserveNewlines").checked = settings.preserveNewlines;
      }
      if (typeof settings.normalizeSpacing === "boolean") {
        document.getElementById("normalizeSpacing").checked = settings.normalizeSpacing;
      }
      
      // Apply appearance settings
      if (typeof settings.darkMode === "boolean") {
        document.getElementById("darkModeToggle").checked = settings.darkMode;
        setDarkMode(settings.darkMode);
      }
      
      // Apply token settings
      initializeTokenList();
      
      // Apply H function settings
      initializeHFunctionsList();
      
      // Apply H function mappings
      updateHMappingUI();
      
      // Set auto-redetect checkbox if it exists
      const autoRedetectCheckbox = document.getElementById("autoRedetectH");
      if (autoRedetectCheckbox) {
        autoRedetectCheckbox.checked = settings.autoRedetectH !== false;
      }
    }
    
    /* --- File Handling --- */
    function handleFileSelection() {
      if (!selectedFile) return;
      
      fileName.textContent = selectedFile.name;
      
      // Format file size
      let size = selectedFile.size;
      let unit = "bytes";
      if (size > 1024) { size = (size / 1024).toFixed(1); unit = "KB"; }
      if (size > 1024) { size = (size / 1024).toFixed(1); unit = "MB"; }
      fileSize.textContent = `${size} ${unit}`;
      
      // Show file info
      fileInfo.style.display = "block";
      
      // Read file
      readFile();
    }
    
    function readFile() {
      if (!selectedFile) return;
      
      const reader = new FileReader();
      
      reader.onload = function (e) {
        fileContent = e.target.result;
        showToast("File loaded successfully", "success");
        
        // Detect units and update UI
        detectedUnit.textContent = detectUnits(fileContent);
        
        try {
          // Run conversion based on detected units
          updateConversion();
          
          // Note: H number detection is now triggered manually
          updateHMappingUI();
        } catch (error) {
          console.error("Conversion error:", error);
          showToast("Conversion error: " + error.message, "error");
        }
      };
      
      reader.onerror = () => {
        console.error("File reading error");
        showToast("Error reading file", "error");
      };
      
      reader.readAsText(selectedFile);
    }
    
    function detectUnits(content) {
      // Check for explicit G-code unit indicators
      const lower = content.toLowerCase();
      if (/g20\b/.test(lower)) {
        document.getElementById("inchToMm").checked = true;
        return "Inches (G20 found)";
      }
      if (/g21\b/.test(lower)) {
        document.getElementById("mmToInch").checked = true;
        return "Millimeters (G21 found)";
      }
      
      // Fall back to analyzing coordinate values
      const matches = content.match(/[XY]\s*-?\d+\.?\d*/g) || [];
      const vals = matches.map(m => parseFloat(m.replace(/[XY]\s*/, "")));
      
      if (vals.length > 0) {
        const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
        if (avg < 30) {
          document.getElementById("inchToMm").checked = true;
          return "Likely Inches (based on values)";
        } else {
          document.getElementById("mmToInch").checked = true;
          return "Likely Millimeters (based on values)";
        }
      }
      
      return "Unknown (No coordinates found)";
    }
    
    /* --- Token Management --- */
    function initializeTokenList() {
      if (!tokenList) return;
      
      // Clear the token list
      tokenList.innerHTML = "";
      
      // Make sure tokens array exists in settings
      if (!Array.isArray(settings.tokens) || settings.tokens.length === 0) {
        settings.tokens = [...DEFAULT_TOKENS];
      }
      
      // Add each token to the list
      settings.tokens.forEach(token => addTokenToList(token));
      
      // Update quick token buttons status
      updateQuickTokenButtons();
    }
    
    function addTokenToList(token) {
      if (!tokenList || !token || !tokenItemTemplate) return;
      
      // Clone the template
      const tokenItem = document.importNode(tokenItemTemplate.content, true);
      
      // Set token name
      const tokenName = tokenItem.querySelector(".token-name");
      tokenName.textContent = token;
      
      // Set up remove button
      const removeBtn = tokenItem.querySelector(".remove-token");
      removeBtn.addEventListener("click", () => removeToken(token));
      
      // Add to the list
      tokenList.appendChild(tokenItem);
      
      // Update quick token buttons state
      updateQuickTokenButtons();
    }
    
    function removeToken(token) {
      if (!tokenList) return;
      
      // Remove from DOM
      const tokenItems = tokenList.querySelectorAll('.token-item');
      tokenItems.forEach(item => {
        const tokenName = item.querySelector('.token-name');
        if (tokenName && tokenName.textContent === token) {
          item.remove();
        }
      });
      
      // Remove from settings
      settings.tokens = settings.tokens.filter(t => t !== token);
      
      // Save and update
      saveSettings(settings);
      updateQuickTokenButtons();
      updateConversion();
      
      showToast(`Token "${token}" removed`, "success");
    }
    
    function addCustomToken() {
      if (!customToken) return;
      
      const token = customToken.value.trim();
      if (!token) {
        showToast("Please enter a token", "error");
        return;
      }
      
      // Check if token already exists
      if (settings.tokens.includes(token)) {
        showToast(`Token "${token}" already exists`, "warning");
        return;
      }
      
      // Add token
      settings.tokens.push(token);
      saveSettings(settings);
      addTokenToList(token);
      
      // Clear input
      customToken.value = "";
      
      // Update UI and conversion
      updateConversion();
      showToast(`Token "${token}" added`, "success");
      
      // Focus back on input for easy addition of multiple tokens
      customToken.focus();
    }
    
    function updateQuickTokenButtons() {
      document.querySelectorAll('.quick-token-btn').forEach(btn => {
        const token = btn.getAttribute('data-token');
        if (settings.tokens.includes(token)) {
          btn.classList.add('disabled');
          btn.disabled = true;
          btn.style.opacity = "0.5";
          btn.style.cursor = "not-allowed";
        } else {
          btn.classList.remove('disabled');
          btn.disabled = false;
          btn.style.opacity = "1";
          btn.style.cursor = "pointer";
        }
      });
    }
    
    function getTokens() { 
      // Always return a valid array of tokens
      return Array.isArray(settings.tokens) && settings.tokens.length > 0 
        ? settings.tokens 
        : [...DEFAULT_TOKENS]; 
    }
    
    /* --- H Function Definition Management --- */
    function initializeHFunctionsList() {
      if (!hFunctionsList) return;
      
      // Clear the list
      hFunctionsList.innerHTML = "";
      
      // Make sure H functions object exists in settings
      if (!settings.hFunctions || typeof settings.hFunctions !== 'object') {
        settings.hFunctions = {...DEFAULT_H_FUNCTIONS};
        saveSettings(settings);
      }
      
      // Get all H functions and sort them numerically
      const hFunctionEntries = Object.entries(settings.hFunctions)
        .sort((a, b) => {
          const numA = parseInt(a[0].replace('H', ''));
          const numB = parseInt(b[0].replace('H', ''));
          return numA - numB;
        });
      
      // Add each H function to the list
      hFunctionEntries.forEach(([key, value]) => {
        addHFunctionToList(key, value);
      });
      
      // Reset edit section
      exitHFunctionEditMode();
    }
    
    function addHFunctionToList(hKey, hName) {
      if (!hFunctionsList || !hFunctionDefItemTemplate) return;
      
      // Clone the template
      const hFunctionItem = document.importNode(hFunctionDefItemTemplate.content, true);
      
      // Set H number and name
      const hNumberElem = hFunctionItem.querySelector(".h-number");
      const hNameElem = hFunctionItem.querySelector(".h-name");
      hNumberElem.textContent = hKey;
      hNameElem.textContent = hName;
      
      // Set up edit button
      const editBtn = hFunctionItem.querySelector(".edit-h-function");
      editBtn.addEventListener("click", () => enterHFunctionEditMode(hKey, hName));
      
      // Set up remove button
      const removeBtn = hFunctionItem.querySelector(".remove-h-function");
      removeBtn.addEventListener("click", () => removeHFunction(hKey));
      
      // Add to the list
      hFunctionsList.appendChild(hFunctionItem);
    }
    
    function addNewHFunction() {
      if (!newHNumber || !newHName) return;
      
      const hNum = newHNumber.value.trim();
      const hName = newHName.value.trim();
      
      // Validate inputs
      if (!hNum || !hName) {
        showToast("Please enter both H number and name", "error");
        return;
      }
      
      // Format H number
      const hKey = `H${hNum}`;
      
      // Check if H function already exists
      if (settings.hFunctions[hKey]) {
        showToast(`H${hNum} already exists. Use edit function instead.`, "warning");
        return;
      }
      
      // Add to settings
      settings.hFunctions[hKey] = hName;
      saveSettings(settings);
      
      // Add to list
      addHFunctionToList(hKey, hName);
      
      // Clear inputs
      newHNumber.value = "";
      newHName.value = "";
      
      // Update UI
      refreshHFunctionData();
      showToast(`H${hNum} added successfully`, "success");
      
      // Focus for easy addition of multiple entries
      newHNumber.focus();
    }
    
    function enterHFunctionEditMode(hKey, hName) {
      if (!editHFunctionSection || !editHNumber || !editHName) return;
      
      // Set the form values
      editHNumber.value = hKey.replace('H', '');
      editHName.value = hName;
      
      // Show edit section
      editHFunctionSection.style.display = "block";
      
      // Track the H function being edited
      currentlyEditingH = hKey;
      
      // Scroll to edit section
      editHFunctionSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    function saveHFunctionEdit() {
      if (!currentlyEditingH || !editHName) return;
      
      const hName = editHName.value.trim();
      
      // Validate input
      if (!hName) {
        showToast("Please enter a name for the H function", "error");
        return;
      }
      
      // Update in settings
      settings.hFunctions[currentlyEditingH] = hName;
      saveSettings(settings);
      
      // Exit edit mode
      exitHFunctionEditMode();
      
      // Refresh UI
      initializeHFunctionsList();
      refreshHFunctionData();
      
      showToast(`${currentlyEditingH} updated successfully`, "success");
    }
    
    function exitHFunctionEditMode() {
      if (!editHFunctionSection) return;
      
      // Hide edit section
      editHFunctionSection.style.display = "none";
      
      // Clear tracking
      currentlyEditingH = null;
      
      // Clear form values
      if (editHNumber) editHNumber.value = "";
      if (editHName) editHName.value = "";
    }
    
    function removeHFunction(hKey) {
      // Confirm deletion
      if (!confirm(`Are you sure you want to delete ${hKey}?`)) {
        return;
      }
      
      // Remove from settings
      delete settings.hFunctions[hKey];
      saveSettings(settings);
      
      // Exit edit mode if deleting the currently edited item
      if (currentlyEditingH === hKey) {
        exitHFunctionEditMode();
      }
      
      // Refresh UI
      initializeHFunctionsList();
      refreshHFunctionData();
      
      showToast(`${hKey} removed successfully`, "success");
    }
    
    function resetHFunctions() {
      // Confirm reset
      if (!confirm("Are you sure you want to reset all H functions to defaults?")) {
        return;
      }
      
      // Reset to defaults
      settings.hFunctions = {...DEFAULT_H_FUNCTIONS};
      saveSettings(settings);
      
      // Exit edit mode
      exitHFunctionEditMode();
      
      // Refresh UI
      initializeHFunctionsList();
      refreshHFunctionData();
      
      showToast("H functions reset to defaults", "success");
    }
    
    function refreshHFunctionData() {
      // This function refreshes H Function data throughout the app
      
      // Update H mappings tab if it's currently visible
      const hFunctionsTab = document.getElementById("hfunctions-tab");
      if (hFunctionsTab && hFunctionsTab.style.display !== 'none') {
        updateHMappingUI();
      }
    }
    
    /* --- UI Helpers --- */
    function setDarkMode(isDark) {
      if (isDark) { 
        document.body.classList.add("dark-mode"); 
      } else { 
        document.body.classList.remove("dark-mode"); 
      }
    }
    
    function showToast(msg, type = "info") {
      toast.textContent = msg;
      toast.className = "toast";
      
      if (type === "error") toast.classList.add("error");
      if (type === "warning") toast.classList.add("warning");
      if (type === "success") toast.classList.add("success");
      
      toast.classList.add("show");
      
      // Hide toast after delay
      setTimeout(() => {
        toast.classList.remove("show");
      }, 3000);
    }
    
    function escapeHtml(text) {
      if (!text) return "";
      return text.toString()
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
    }
    
    /* --- Auto-Redetect Option --- */
    function addAutoRedetectOption() {
      const hfunctionsTab = document.getElementById("hfunctions-tab");
      if (!hfunctionsTab) return;
      
      // Create a settings option for auto re-detection
      const settingDiv = document.createElement("div");
      settingDiv.className = "checkbox-option";
      settingDiv.style.marginTop = "var(--space-4)";
      
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.id = "autoRedetectH";
      checkbox.checked = settings.autoRedetectH !== false; // Default to true
      
      const label = document.createElement("label");
      label.htmlFor = "autoRedetectH";
      label.textContent = "Automatically detect H numbers in modified file when changing mappings";
      
      settingDiv.appendChild(checkbox);
      settingDiv.appendChild(label);
      
      // Insert before the reset button
      const resetBtn = document.getElementById("resetHMappingBtn");
      if (resetBtn) {
        resetBtn.parentNode.insertBefore(settingDiv, resetBtn);
      } else {
        hfunctionsTab.appendChild(settingDiv);
      }
      
      // Add event listener to save setting
      checkbox.addEventListener("change", () => {
        settings.autoRedetectH = checkbox.checked;
        saveSettings(settings);
      });
    }
    
    /* --- Event Listeners --- */
    // Tab switching
    tabHeaders.forEach(header => {
      header.addEventListener("click", function () {
        // Get the tab we're switching to
        const tabName = this.getAttribute("data-tab");
        
        // Update the active tab
        tabHeaders.forEach(h => h.classList.remove("active"));
        tabContents.forEach(content => (content.style.display = "none"));
        this.classList.add("active");
        document.getElementById(tabName + "-tab").style.display = "block";
        
        // If switching to H functions tab, detect H numbers from converted file
        if (tabName === "hfunctions" && convertedContent) {
          updateHMappingFromFile(true); // true = use converted content
          updateHMappingUI();
        }
      });
    });
    
    // File area click and drag/drop support
    fileArea.addEventListener("click", () => fileInput.click());
    
    fileArea.addEventListener("dragover", function(e) {
      e.preventDefault();
      fileArea.classList.add("hover");
      e.dataTransfer.dropEffect = "copy";
    });
    
    fileArea.addEventListener("dragleave", function(e) {
      e.preventDefault();
      fileArea.classList.remove("hover");
    });
    
    fileArea.addEventListener("drop", function(e) {
      e.preventDefault();
      fileArea.classList.remove("hover");
      if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
        selectedFile = e.dataTransfer.files[0];
        handleFileSelection();
      }
    });
    
    fileInput.addEventListener("change", (e) => {
      if (e.target.files && e.target.files.length > 0) {
        selectedFile = e.target.files[0];
        handleFileSelection();
      }
    });
    
    // Setting change listeners
    document.getElementById("mmPrecision").addEventListener("change", () => {
      updateConversion();
      updateStoredSettings();
    });
    
    document.getElementById("inchPrecision").addEventListener("change", () => {
      updateConversion();
      updateStoredSettings();
    });
    
    document.getElementById("preserveNewlines").addEventListener("change", () => {
      updateConversion();
      updateStoredSettings();
    });
    
    document.getElementById("normalizeSpacing").addEventListener("change", () => {
      updateConversion();
      updateStoredSettings();
    });
    
    document.querySelectorAll('input[name="conversionType"]').forEach(el =>
      el.addEventListener("change", () => {
        updateConversion();
        updateStoredSettings();
      })
    );
    
    // Dark mode toggle
    darkModeToggle.addEventListener("change", () => {
      const isDark = darkModeToggle.checked;
      setDarkMode(isDark);
      updateStoredSettings();
    });
    
    // Reset settings button
    resetSettingsBtn.addEventListener("click", resetSettings);
    
    // Token management
    if (addTokenBtn && customToken) {
      addTokenBtn.addEventListener("click", addCustomToken);
      
      // Allow pressing Enter to add token
      customToken.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          addCustomToken();
        }
      });
    }
    
    // Token reset button
    if (resetTokensBtn) {
      resetTokensBtn.addEventListener("click", () => {
        settings.tokens = [...DEFAULT_TOKENS];
        saveSettings(settings);
        initializeTokenList();
        updateConversion();
        showToast("Tokens reset to defaults", "success");
      });
    }
    
    // Quick token buttons
    document.querySelectorAll('.quick-token-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const token = btn.getAttribute('data-token');
        if (!token) return;
        
        // Skip if already in the list
        if (settings.tokens.includes(token)) {
          showToast(`Token "${token}" already exists`, "warning");
          return;
        }
        
        // Add the token
        settings.tokens.push(token);
        saveSettings(settings);
        addTokenToList(token);
        updateConversion();
        showToast(`Token "${token}" added`, "success");
      });
    });
    
    // H function definition management
    if (addHFunctionBtn) {
      addHFunctionBtn.addEventListener("click", addNewHFunction);
      
      // Allow pressing Enter to add H function
      if (newHName) {
        newHName.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            addNewHFunction();
          }
        });
      }
    }
    
    if (saveHFunctionBtn) {
      saveHFunctionBtn.addEventListener("click", saveHFunctionEdit);
    }
    
    if (cancelEditHFunctionBtn) {
      cancelEditHFunctionBtn.addEventListener("click", exitHFunctionEditMode);
    }
    
    if (resetHFunctionsBtn) {
      resetHFunctionsBtn.addEventListener("click", resetHFunctions);
    }
    
    // H number detection button
    if (detectHBtn) {
      detectHBtn.addEventListener("click", () => {
        // Always detect from converted file if available
        updateHMappingFromFile(convertedContent ? true : false);
        updateHMappingUI();
        showToast("H numbers detected and mappings updated", "success");
      });
    }
    
    // Reset H mappings button
    if (resetHMappingBtn) {
      resetHMappingBtn.addEventListener("click", () => {
        if (confirm("Are you sure you want to reset all H function mappings?")) {
          hMapping = [];
          saveHMapping(hMapping);
          updateHMappingUI();
          updateConversion();
          showToast("H mappings have been reset", "success");
        }
      });
    }
    /* --- Version information --- */
    const APP_VERSION = "1.0.0"; // Change this when releasing new versions
    const GITHUB_USER = "aardel";
    const GITHUB_REPO = "nc-file-converter";
    const VERSION_CHECK_INTERVAL = 24 * 60 * 60 * 1000; // Check once per day (in ms)
    
    /* --- Conversion Functions --- */
    function inchToMm(content, tokens, precision) {
      if (!tokens || tokens.length === 0) {
        return content; // No conversion if no tokens
      }
      
      try {
        const pattern = new RegExp("(" + tokens.map(t => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|") +
          ")(\\s*)(-?\\d+(?:\\.\\d+)?)", "gi");
        
        let result = content.replace(pattern, (match, token, space, num) => {
          let val = parseFloat(num);
          return token + space + (val * 25.4).toFixed(precision);
        });
        
        if (document.getElementById("normalizeSpacing").checked) {
          result = result.replace(/([A-Z])\s+(-?\d+(?:\.\d+)?)/gi, "$1$2");
        }
        
        return result;
      } catch (error) {
        console.error("Error in inchToMm conversion:", error);
        showToast(`Error in inchToMm conversion: ${error.message}`, "error");
        return content; // Return original content on error
      }
    }
    
    function mmToInch(content, tokens, precision) {
      if (!tokens || tokens.length === 0) {
        return content; // No conversion if no tokens
      }
      
      try {
        const pattern = new RegExp("(" + tokens.map(t => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|") +
          ")(\\s*)(-?\\d+(?:\\.\\d+)?)", "gi");
        
        let result = content.replace(pattern, (match, token, space, num) => {
          let val = parseFloat(num);
          return token + space + (val / 25.4).toFixed(precision);
        });
        
        if (document.getElementById("normalizeSpacing").checked) {
          result = result.replace(/([A-Z])\s+(-?\d+(?:\.\d+)?)/gi, "$1$2");
        }
        
        return result;
      } catch (error) {
        console.error("Error in mmToInch conversion:", error);
        showToast(`Error in mmToInch conversion: ${error.message}`, "error");
        return content; // Return original content on error
      }
    }
    
    /* --- Main Conversion Logic --- */
    function updateConversion(redetectH = false) {
      if (!fileContent) {
        console.log("No file content to convert");
        return;
      }
      
      const tokens = getTokens();
      
      if (tokens.length === 0) {
        showToast("No tokens defined. Please add tokens in the Settings tab.", "warning");
        convertedContent = fileContent; // Just copy original content
        updatePreview();
        return;
      }
      
      const conversionType = document.querySelector('input[name="conversionType"]:checked').value;
      const mmPrec = parseInt(document.getElementById("mmPrecision").value) || 3;
      const inchPrec = parseInt(document.getElementById("inchPrecision").value) || 4;
      
      try {
        // Determine conversion direction based on setting or auto-detection
        if (conversionType === "autoDetect") {
          const detected = detectedUnit.textContent;
          
          if (detected.includes("Inch")) {
            convertedContent = inchToMm(fileContent, tokens, mmPrec);
            finalUnits = "mm";
            createDownloadLink("inchToMm");
          } else if (detected.includes("Millimeter")) {
            convertedContent = mmToInch(fileContent, tokens, inchPrec);
            finalUnits = "inches";
            createDownloadLink("mmToInch");
          } else {
            showToast("Cannot auto-detect units. Please select a conversion direction.", "error");
            return;
          }
        } else if (conversionType === "inchToMm") {
          convertedContent = inchToMm(fileContent, tokens, mmPrec);
          finalUnits = "mm";
          createDownloadLink("inchToMm");
        } else { // mmToInch
          convertedContent = mmToInch(fileContent, tokens, inchPrec);
          finalUnits = "inches";
          createDownloadLink("mmToInch");
        }
        
        // Ensure we have content
        if (!convertedContent) { 
          convertedContent = fileContent; 
        }
        
        // Apply H function mappings
        convertedContent = applyHMapping(convertedContent);
        
        // Check if we should re-detect H numbers
        const autoRedetectEnabled = document.getElementById("autoRedetectH") ? 
                                   document.getElementById("autoRedetectH").checked : 
                                   settings.autoRedetectH !== false;
                                    
        if (redetectH && autoRedetectEnabled) {
          updateHMappingFromFile(true); // true = use convertedContent
          updateHMappingUI();
        }
      } catch (error) {
        console.error("Conversion error:", error);
        showToast("Conversion error: " + error.message, "error");
        return;
      }
      
      // Update UI and settings
      updateStoredSettings();
      updatePreview();
      updateExportButton();
      
      // Clear any search results when content changes
      clearSearchHighlights();
      
      // Enable download button
      downloadConvertedBtn.disabled = false;
      
      showToast("Conversion complete!", "success");
    }
    
    /* --- H Function Mapping --- */
    function updateHMappingFromFile(useConvertedContent = false) {
      // Use either the converted content (if available and requested) or the original content
      const contentToAnalyze = useConvertedContent && convertedContent ? convertedContent : fileContent;
      
      if (!contentToAnalyze) {
        console.log("No content to analyze for H functions");
        return;
      }
      
      // Use word boundaries to capture H numbers
      let matches = contentToAnalyze.match(/\bH\d+\b/gi) || [];
      const distinct = [...new Set(matches.map(h => h.toUpperCase()))];
      
      // Ensure hMapping is an array and filter out invalid entries
      if (!Array.isArray(hMapping)) { 
        hMapping = []; 
      }
      
      // Keep track of existing mappings
      const existingMappings = {};
      hMapping.forEach(m => {
        if (m && m.from) {
          existingMappings[m.from.toUpperCase()] = m.to;
        }
      });
      
      // Create a new hMapping array
      let newMapping = [];
      
      // Add all distinct H numbers found in the content
      distinct.forEach(hnum => {
        if (existingMappings[hnum]) {
          // If we already have a mapping for this H number, preserve it
          newMapping.push({ from: hnum, to: existingMappings[hnum] });
        } else {
          // Otherwise create a new mapping (from = to)
          newMapping.push({ from: hnum, to: hnum });
        }
      });
      
      // Assign the new mapping and save it
      hMapping = newMapping;
      saveHMapping(hMapping);
    }
    
    // Updated H Mapping UI function to fix issue with H function highlighting
    function updateHMappingUI() {
      if (!hMappingContainer || !hMappingItemTemplate) return;
      
      // Clear the container
      hMappingContainer.innerHTML = "";
      
      // Add empty state message if no H numbers found
      if (!hMapping || hMapping.length === 0) {
        const emptyMessage = document.createElement("p");
        emptyMessage.className = "empty-message";
        emptyMessage.style.fontStyle = "italic";
        emptyMessage.style.color = "var(--gray-500)";
        emptyMessage.style.textAlign = "center";
        emptyMessage.style.padding = "var(--space-3)";
        emptyMessage.textContent = "No H numbers detected. Click 'Detect H Numbers' to scan your file or upload a file containing H numbers.";
        hMappingContainer.appendChild(emptyMessage);
        return;
      }
      
      // Create rows for each H number mapping
      hMapping.forEach((map, index) => {
        if (!map || !map.from) return;
        
        // Clone the template
        const row = document.importNode(hMappingItemTemplate.content, true);
        
        // Original H function with friendly name
        const origValue = map.from;
        const friendly = getHFunctionName(origValue);
        
        // Set original H function text
        const origDisplay = row.querySelector(".h-original");
        origDisplay.textContent = origValue + " (" + friendly + ")";
        
        // Set up mapping select
        const newSelect = row.querySelector(".h-mapping");
        newSelect.innerHTML = getHFunctionOptionsHTML();
        newSelect.value = map.to || origValue;
        newSelect.addEventListener("change", () => {
          // Store the original value to check if it changed
          const oldTo = map.to;
          
          // Update the mapping
          map.to = newSelect.value;
          saveHMapping(hMapping);
          
          // Only run full conversion if mapping actually changed
          if (oldTo !== map.to) {
            if (convertedContent) {
              // Apply mappings directly to convertedContent without re-running the full conversion
              convertedContent = applyHMapping(convertedContent);
              
              // Force preview update
              updatePreview();
              
              // Update export button state
              updateExportButton();
              
              showToast(`${map.from} mapped to ${map.to}`, "success");
            } else {
              // If no converted content yet, run full conversion
              updateConversion(true);
            }
          }
        });
        
        // Set up remove button
        const removeBtn = row.querySelector(".remove-mapping");
        removeBtn.addEventListener("click", () => {
          hMapping.splice(index, 1);
          saveHMapping(hMapping);
          
          if (convertedContent) {
            // Force conversion update
            updateConversion(true);
          }
        });
        
        // Add to container
        hMappingContainer.appendChild(row);
      });
    }
    
    function getHFunctionName(hKey) {
      // Get the friendly name from settings or return "Unknown"
      return settings.hFunctions && settings.hFunctions[hKey] 
        ? settings.hFunctions[hKey] 
        : "Unknown";
    }
    
    function getHFunctionOptionsHTML() {
      // Generate options from the current hFunctions settings
      let optionsHTML = '';
      
      // Group H functions by category
      const woodCutting = [];
      const steelCutting = [];
      const milling = [];
      const other = [];
      
      // Get all H functions from settings
      const hFunctionEntries = Object.entries(settings.hFunctions)
        .sort((a, b) => {
          const numA = parseInt(a[0].replace('H', ''));
          const numB = parseInt(b[0].replace('H', ''));
          return numA - numB;
        });
      
      // Categorize based on number ranges
      hFunctionEntries.forEach(([key, value]) => {
        const hNum = parseInt(key.replace('H', ''));
        
        if (hNum >= 1 && hNum < 40) {
          woodCutting.push([key, value]);
        } else if (hNum >= 40 && hNum < 100) {
          steelCutting.push([key, value]);
        } else if (hNum >= 100) {
          milling.push([key, value]);
        } else {
          other.push([key, value]);
        }
      });
      
      // Build the options HTML
      
      // Wood Cutting
      if (woodCutting.length > 0) {
        optionsHTML += '<optgroup label="Wood Cutting">';
        woodCutting.forEach(([key, value]) => {
          optionsHTML += `<option value="${key}">${value} (${key})</option>`;
        });
        optionsHTML += '</optgroup>';
      }
      
      // Steel Cutting
      if (steelCutting.length > 0) {
        optionsHTML += '<optgroup label="Steel Cutting">';
        steelCutting.forEach(([key, value]) => {
          optionsHTML += `<option value="${key}">${value} (${key})</option>`;
        });
        optionsHTML += '</optgroup>';
      }
      
      // Milling
      if (milling.length > 0) {
        optionsHTML += '<optgroup label="Milling">';
        milling.forEach(([key, value]) => {
          optionsHTML += `<option value="${key}">${value} (${key})</option>`;
        });
        optionsHTML += '</optgroup>';
      }
      
      // Other
      if (other.length > 0) {
        optionsHTML += '<optgroup label="Other">';
        other.forEach(([key, value]) => {
          optionsHTML += `<option value="${key}">${value} (${key})</option>`;
        });
        optionsHTML += '</optgroup>';
      }
      
      return optionsHTML;
    }
    
    function applyHMapping(content) {
      if (!hMapping || !Array.isArray(hMapping) || hMapping.length === 0) {
        return content;
      }
      
      try {
        let modifiedContent = content;
        
        hMapping.forEach(map => {
          if (map && map.from && map.to) {
            const regex = new RegExp("\\b" + map.from + "\\b", "gi");
            modifiedContent = modifiedContent.replace(regex, map.to);
          }
        });
        
        return modifiedContent;
      } catch (error) {
        console.error("Error applying H mappings:", error);
        return content; // Return original on error
      }
    }
    
    /* --- Preview Functions --- */
    function updatePreview() {
      if (!originalPreview || !convertedPreview) return;
      
      if (!fileContent) {
        originalPreview.innerHTML = "No file loaded.";
        convertedPreview.innerHTML = "No conversion available.";
        return;
      }
      
      try {
        // Get tokens for highlighting
        const tokens = getTokens();
        
        // ---- ORIGINAL CODE PREVIEW ----
        let originalText = escapeHtml(fileContent);
        
        // First highlight H functions that will be changed (in red)
        if (hMapping && hMapping.length > 0) {
          // Get mappings where from != to (i.e., H functions that will be changed)
          const changedMappings = hMapping.filter(m => m && m.from && m.to && m.from !== m.to);
          
          // For each mapping, highlight all occurrences in the original text
          changedMappings.forEach(mapping => {
            // Create a pattern to match the exact H number with word boundaries
            const pattern = new RegExp("\\b" + escapeRegExp(mapping.from) + "\\b", "g");
            
            // Replace with highlighted version
            originalText = originalText.replace(pattern, '<span class="highlight-h-function">$&</span>');
          });
        }
        
        // Then highlight tokens (in blue)
        if (tokens.length > 0) {
          const tokenPattern = new RegExp("(" + tokens.map(t => escapeRegExp(t)).join("|") +
            ")(\\s*)(-?\\d+(?:\\.\\d+)?)", "gi");
          originalText = originalText.replace(tokenPattern, '<span class="highlight-token">$&</span>');
        }
        
        // Update original preview
        originalPreview.innerHTML = originalText;
        
        // ---- CONVERTED CODE PREVIEW ----
        if (convertedContent) {
          let convertedText = escapeHtml(convertedContent);
          
          // First highlight mapped H functions in converted text
          if (hMapping && hMapping.length > 0) {
            // Get mappings where from != to (i.e., H functions that were changed)
            const changedMappings = hMapping.filter(m => m && m.from && m.to && m.from !== m.to);
            
            // For each mapping, highlight all occurrences of the destination H function
            changedMappings.forEach(mapping => {
              // Create a pattern to match the exact replacement H number
              const pattern = new RegExp("\\b" + escapeRegExp(mapping.to) + "\\b", "g");
              
              // Replace with highlighted version
              convertedText = convertedText.replace(pattern, '<span class="highlight-h-function">$&</span>');
            });
          }
          
          // Then highlight converted tokens (in blue)
          if (tokens.length > 0) {
            const tokenPattern = new RegExp("(" + tokens.map(t => escapeRegExp(t)).join("|") +
              ")(\\s*)(-?\\d+(?:\\.\\d+)?)", "gi");
            convertedText = convertedText.replace(tokenPattern, '<span class="highlight-token">$&</span>');
          }
          
          // Update converted preview
          convertedPreview.innerHTML = convertedText;
        } else {
          convertedPreview.innerHTML = "Not converted yet.";
        }
      } catch (error) {
        console.error("Error updating preview:", error);
        
        // Fallback to simple text display if highlighting fails
        originalPreview.innerHTML = escapeHtml(fileContent);
        convertedPreview.innerHTML = convertedContent ? escapeHtml(convertedContent) : "Not converted yet.";
      }
    }
    
    // Helper function to escape regular expression special characters
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    /* --- Search Functionality --- */
    let searchMatches = [];
    let currentMatchIndex = -1;
    
    function initializePreviewSearch() {
      const searchInput = document.getElementById('previewSearchInput');
      const searchBtn = document.getElementById('previewSearchBtn');
      const prevMatchBtn = document.getElementById('prevMatchBtn');
      const nextMatchBtn = document.getElementById('nextMatchBtn');
      const searchCaseSensitive = document.getElementById('searchCaseSensitive');
      
      if (!searchInput || !searchBtn || !prevMatchBtn || !nextMatchBtn) return;
      
      // Search event listeners
      searchBtn.addEventListener('click', () => performSearch());
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') performSearch();
      });
      
      // Navigation buttons
      prevMatchBtn.addEventListener('click', () => navigateSearch(-1));
      nextMatchBtn.addEventListener('click', () => navigateSearch(1));
      
      // Case sensitive toggle
      searchCaseSensitive.addEventListener('change', () => {
        if (searchInput.value.trim()) performSearch();
      });
    }
    
    function performSearch() {
      const searchInput = document.getElementById('previewSearchInput');
      const searchResultsInfo = document.getElementById('searchResultsInfo');
      const searchCaseSensitive = document.getElementById('searchCaseSensitive');
      const prevMatchBtn = document.getElementById('prevMatchBtn');
      const nextMatchBtn = document.getElementById('nextMatchBtn');
      
      if (!searchInput || !convertedPreview || !searchResultsInfo) return;
      
      const searchTerm = searchInput.value.trim();
      if (!searchTerm) {
        clearSearchHighlights();
        searchResultsInfo.textContent = '';
        prevMatchBtn.disabled = true;
        nextMatchBtn.disabled = true;
        return;
      }
      
      // Reset current matches
      clearSearchHighlights();
      searchMatches = [];
      currentMatchIndex = -1;
      
      // Get converted preview content
      const previewContent = convertedPreview.innerHTML;
      
      // Create a temporary div to parse the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = previewContent;
      
      // Get the text content of the preview
      const textContent = tempDiv.textContent || tempDiv.innerText;
      
      // Find all matches
      const caseSensitive = searchCaseSensitive.checked;
      const flags = caseSensitive ? 'g' : 'gi';
      const regex = new RegExp(escapeRegExp(searchTerm), flags);
      
      let match;
      while ((match = regex.exec(textContent)) !== null) {
        searchMatches.push({
          start: match.index,
          end: match.index + match[0].length,
          text: match[0]
        });
      }
      
      // Update search results info
      if (searchMatches.length === 0) {
        searchResultsInfo.textContent = 'No matches found';
        prevMatchBtn.disabled = true;
        nextMatchBtn.disabled = true;
        return;
      }
      
      // Update buttons and info
      prevMatchBtn.disabled = false;
      nextMatchBtn.disabled = false;
      
      // Highlight all matches
      highlightMatches();
      
      // Select the first match
      currentMatchIndex = 0;
      updateCurrentMatch();
      
      // Update results info
      searchResultsInfo.textContent = `Match ${currentMatchIndex + 1} of ${searchMatches.length}`;
    }
    
    function highlightMatches() {
      if (!convertedPreview || searchMatches.length === 0) return;
      
      // Create a document fragment
      const fragment = document.createDocumentFragment();
      const container = document.createElement('div');
      container.innerHTML = convertedPreview.innerHTML;
      
      // Create a text node walker to navigate the DOM
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      // Collect all text nodes
      const textNodes = [];
      let currentNode;
      while (currentNode = walker.nextNode()) {
        textNodes.push(currentNode);
      }
      
      // Get text offsets
      let currentOffset = 0;
      const nodePositions = textNodes.map(node => {
        const position = {
          node,
          start: currentOffset,
          end: currentOffset + node.nodeValue.length
        };
        currentOffset += node.nodeValue.length;
        return position;
      });
      
      // Process each match
      searchMatches.forEach((match, index) => {
        // Find nodes that contain this match
        const relevantPositions = nodePositions.filter(
          pos => (match.start < pos.end && match.end > pos.start)
        );
        
        relevantPositions.forEach((pos, posIndex) => {
          const node = pos.node;
          const nodeStart = pos.start;
          
          // Calculate relative positions within this text node
          const matchStartInNode = Math.max(0, match.start - nodeStart);
          const matchEndInNode = Math.min(node.nodeValue.length, match.end - nodeStart);
          
          if (matchStartInNode < matchEndInNode) {
            // Replace this text node with three pieces:
            // 1. text before match
            // 2. match with highlight
            // 3. text after match
            const beforeMatch = node.nodeValue.substring(0, matchStartInNode);
            const matchText = node.nodeValue.substring(matchStartInNode, matchEndInNode);
            const afterMatch = node.nodeValue.substring(matchEndInNode);
            
            const parentNode = node.parentNode;
            
            if (beforeMatch) {
              parentNode.insertBefore(document.createTextNode(beforeMatch), node);
            }
            
            // Create highlight span
            const highlightSpan = document.createElement('span');
            highlightSpan.className = 'search-match';
            highlightSpan.dataset.matchIndex = index;
            highlightSpan.textContent = matchText;
            parentNode.insertBefore(highlightSpan, node);
            
            if (afterMatch) {
              parentNode.insertBefore(document.createTextNode(afterMatch), node);
            }
            
            parentNode.removeChild(node);
          }
        });
      });
      
      // Update preview with highlighted content
      convertedPreview.innerHTML = container.innerHTML;
    }
    
    function navigateSearch(direction) {
      if (searchMatches.length === 0) return;
      
      // Remove current highlight
      clearCurrentMatch();
      
      // Update index
      currentMatchIndex += direction;
      if (currentMatchIndex < 0) currentMatchIndex = searchMatches.length - 1;
      if (currentMatchIndex >= searchMatches.length) currentMatchIndex = 0;
      
      // Apply new current highlight
      updateCurrentMatch();
      
      // Update info text
      const searchResultsInfo = document.getElementById('searchResultsInfo');
      if (searchResultsInfo) {
        searchResultsInfo.textContent = `Match ${currentMatchIndex + 1} of ${searchMatches.length}`;
      }
    }
    
    function clearCurrentMatch() {
      if (!convertedPreview) return;
      
      const currentElements = convertedPreview.querySelectorAll('.search-match.current');
      currentElements.forEach(el => {
        el.classList.remove('current');
      });
    }
    
    function updateCurrentMatch() {
      if (!convertedPreview || currentMatchIndex < 0 || currentMatchIndex >= searchMatches.length) return;
      
      const matchElements = convertedPreview.querySelectorAll('.search-match');
      const currentElement = Array.from(matchElements).find(
        el => parseInt(el.dataset.matchIndex) === currentMatchIndex
      );
      
      if (currentElement) {
        currentElement.classList.add('current');
        currentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
    
    function clearSearchHighlights() {
      if (!convertedPreview) return;
      
      // Option 1: Simple search/replace on the HTML
      let content = convertedPreview.innerHTML;
      content = content.replace(/<span class="search-match[^"]*"[^>]*>(.*?)<\/span>/g, '$1');
      convertedPreview.innerHTML = content;
      
      // Reset search state
      searchMatches = [];
      currentMatchIndex = -1;
      
      // Disable navigation buttons
      const prevMatchBtn = document.getElementById('prevMatchBtn');
      const nextMatchBtn = document.getElementById('nextMatchBtn');
      if (prevMatchBtn) prevMatchBtn.disabled = true;
      if (nextMatchBtn) nextMatchBtn.disabled = true;
    }
    
    /* --- Export Functions --- */
    function createDownloadLink(conversionType) {
      if (!convertedContent || !selectedFile || !downloadConvertedBtn) return;
      
      // Instead of creating the blob now, we'll set up the click handler
      // to create the blob at the time of download
      downloadConvertedBtn.onclick = () => {
        // Create the blob with the CURRENT state of convertedContent
        const blob = new Blob([convertedContent], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement("a");
        a.href = url;
        
        // Create filename with appropriate suffix
        const orig = selectedFile.name;
        const dotIndex = orig.lastIndexOf(".");
        const suffix = conversionType === "inchToMm" ? "mm" : "inch";
        
        a.download = dotIndex !== -1
          ? orig.substring(0, dotIndex) + "_" + suffix + orig.substring(dotIndex)
          : orig + "_" + suffix;
          
        // Trigger download
        a.click();
        
        // Clean up the URL object after download
        setTimeout(() => {
          URL.revokeObjectURL(url);
        }, 100);
      };
    }
    
    function updateExportButton() {
      if (!exportDxfBtn) return;
      const enable = convertedContent && convertedContent.length > 0;
      exportDxfBtn.disabled = !enable;
    }
    
    /* --- DXF Export --- */
    if (exportDxfBtn) {
      exportDxfBtn.addEventListener("click", () => {
        if (!convertedContent) {
          showToast("No converted code available", "error");
          return;
        }
        
        try {
          exportAsDXF();
          showToast("DXF export created", "success");
        } catch (e) {
          console.error("DXF export error:", e);
          showToast("Failed to export as DXF: " + e.message, "error");
        }
      });
    }
    
    function exportAsDXF() {
      // Generate DXF header
      let dxfContent =
        `0
SECTION
2
HEADER
9
$ACADVER
1
AC1009
9
$INSBASE
10
0.0
20
0.0
30
0.0
0
ENDSEC
0
SECTION
2
ENTITIES
`;

      // Add polyline entity
      dxfContent +=
        `0
POLYLINE
8
0
66
1
10
0.0
20
0.0
30
0.0
70
0
`;

      // Add vertices from NC file coordinates
      const lines = convertedContent.split("\n");
      lines.forEach((line) => {
        const xMatch = line.match(/X\s*(-?\d+(?:\.\d+)?)/i);
        const yMatch = line.match(/Y\s*(-?\d+(?:\.\d+)?)/i);
        
        if (xMatch && yMatch) {
          dxfContent +=
            `0
VERTEX
8
0
10
${xMatch[1]}
20
${yMatch[1]}
30
0.0
`;
        }
      });

      // Add polyline end and close DXF
      dxfContent +=
        `0
SEQEND
8
0
`;

      dxfContent +=
        `0
ENDSEC
0
SECTION
2
OBJECTS
0
ENDSEC
0
EOF
`;

      // Create file and trigger download
      const blob = new Blob([dxfContent], { type: "application/dxf" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.download = (selectedFile ? selectedFile.name.split(".")[0] : "nc-file") + ".dxf";
      a.href = url;
      a.click();
      
      // Clean up URL object after download
      setTimeout(() => {
        URL.revokeObjectURL(url);
      }, 100);
    }
    
    /* --- Version Check System --- */
    function checkForUpdates(manual = false) {
      // Don't check too frequently unless it's a manual check
      const lastCheck = localStorage.getItem('lastUpdateCheck');
      const now = Date.now();
      
      if (!manual && lastCheck && (now - parseInt(lastCheck)) < VERSION_CHECK_INTERVAL) {
          console.log("Skipping update check - checked recently");
          return Promise.resolve();
      }
      
      // Record this check time
      localStorage.setItem('lastUpdateCheck', now.toString());
      
      // Update the last check display
      const lastCheckElem = document.getElementById('lastUpdateCheck');
      if (lastCheckElem) {
          lastCheckElem.textContent = new Date().toLocaleString();
      }
      
      const updateStatus = document.getElementById('updateStatus');
      
      return fetch(`https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/main/version.json?nocache=${now}`)
          .then(response => {
              if (!response.ok) {
                  throw new Error(`Failed to fetch version info: ${response.status}`);
              }
              return response.json();
          })
          .then(data => {
              if (data && data.version) {
                  const latestVersion = data.version;
                  
                  if (compareVersions(latestVersion, APP_VERSION) > 0) {
                      // Show update notification
                      showUpdateNotification(latestVersion, data.releaseNotes || "Bug fixes and improvements");
                      if (updateStatus) {
                          updateStatus.innerHTML = `<span style="color: var(--warning-color);">New version ${latestVersion} available!</span>`;
                      }
                  } else if (manual) {
                      if (updateStatus) {
                          updateStatus.innerHTML = `<span style="color: var(--success-color);">You have the latest version!</span>`;
                      }
                  }
              }
          })
          .catch(error => {
              console.error("Error checking for updates:", error);
              if (updateStatus) {
                  updateStatus.innerHTML = `<span style="color: var(--danger-color);">Error checking for updates: ${error.message}</span>`;
              }
              if (manual) {
                  throw error; // Re-throw for manual checks
              }
          });
  }
    
    // Simple semantic version comparison (returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal)
    function compareVersions(v1, v2) {
      const parts1 = v1.split('.').map(Number);
      const parts2 = v2.split('.').map(Number);
      
      for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
        const p1 = i < parts1.length ? parts1[i] : 0;
        const p2 = i < parts2.length ? parts2[i] : 0;
        
        if (p1 > p2) return 1;
        if (p1 < p2) return -1;
      }
      
      return 0;
    }
    
    // Show update notification to the user
    function showUpdateNotification(newVersion, releaseNotes) {
      // Create update notification element
      const updateNotification = document.createElement('div');
      updateNotification.className = 'update-notification';
      updateNotification.innerHTML = `
        <div class="update-card">
          <div class="update-header">
            <h3>New Version Available</h3>
            <button class="close-update">&times;</button>
          </div>
          <div class="update-content">
            <p>A new version of NC File Converter (${newVersion}) is available!</p>
            <p><strong>What's new:</strong> ${releaseNotes}</p>
          </div>
          <div class="update-footer">
            <a href="https://github.com/${GITHUB_USER}/${GITHUB_REPO}/releases/latest" 
               target="_blank" class="update-button">Download Update</a>
            <button class="update-remind">Remind Me Later</button>
          </div>
        </div>
      `;
      
      // Add styles for the notification
      const styleElement = document.createElement('style');
      styleElement.textContent = `
        .update-notification {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          animation: fadeIn 0.3s ease-out;
        }
        
        .update-card {
          background-color: var(--gray-100);
          border-radius: var (--border-radius);
          box-shadow: var(--shadow-lg);
          width: 90%;
          max-width: 500px;
          overflow: hidden;
          animation: slideIn 0.3s ease-out;
        }
        
        .update-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: var(--space-3);
          background-color: var(--primary-color);
          color: white;
        }
        
        .update-header h3 {
          margin: 0;
        }
        
        .close-update {
          background: none;
          border: none;
          color: white;
          font-size: 24px;
          cursor: pointer;
          padding: 0;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .update-content {
          padding: var(--space-3);
        }
        
        .update-footer {
          padding: var(--space-3);
          display: flex;
          justify-content: flex-end;
          gap: var(--space-2);
          border-top: 1px solid var(--gray-300);
        }
        
        .update-button {
          background-color: var(--primary-color);
          color: white;
          padding: var (--space-2) var(--space-3);
          border: none;
          border-radius: var(--border-radius-sm);
          cursor: pointer;
          text-decoration: none;
          font-weight: 500;
          display: inline-block;
        }
        
        .update-button:hover {
          background-color: var(--primary-hover);
          color: white;
          text-decoration: none;
        }
        
        .update-remind {
          background-color: var(--gray-400);
          color: var (--gray-800);
          padding: var(--space-2) var(--space-3);
          border: none;
          border-radius: var(--border-radius-sm);
          cursor: pointer;
        }
        
        .update-remind:hover {
          background-color: var(--gray-500);
        }
        
        @keyframes slideIn {
          from { transform: translateY(-50px); opacity: 0; }
          to { transform: translateY(0); opacity: 1; }
        }
      `;
      
      // Add to document
      document.head.appendChild(styleElement);
      document.body.appendChild(updateNotification);
      
      // Add event listeners
      const closeBtn = updateNotification.querySelector('.close-update');
      const remindBtn = updateNotification.querySelector('.update-remind');
      
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(updateNotification);
      });
      
      remindBtn.addEventListener('click', () => {
        document.body.removeChild(updateNotification);
        // Reset the last check time to a few days ago to remind later
        const remindTime = Date.now() - VERSION_CHECK_INTERVAL + (24 * 60 * 60 * 1000); // Check again in 1 day
        localStorage.setItem('lastUpdateCheck', remindTime.toString());
      });
    }
    
    /* --- Initialize on page load --- */
    document.addEventListener("DOMContentLoaded", () => {
      console.log("NC Converter initialized");
      
      // Load settings
      settings = loadSettings();
      
      // Add the auto-redetect option to H Functions tab
      addAutoRedetectOption();
      
      // Apply settings to UI
      applySettings();
      
      // Initialize search functionality
      initializePreviewSearch();
      
      // Check for updates
      checkForUpdates();
      
      // Initialize update checker
      const currentVersionElem = document.getElementById('currentVersion');
      if (currentVersionElem) {
          currentVersionElem.textContent = APP_VERSION;
      }
      
      const checkUpdateBtn = document.getElementById('checkUpdateBtn');
      if (checkUpdateBtn) {
          checkUpdateBtn.addEventListener('click', () => {
              checkUpdateBtn.disabled = true;
              checkUpdateBtn.textContent = 'Checking...';
              
              checkForUpdates(true) // true = manual check
                  .finally(() => {
                      checkUpdateBtn.disabled = false;
                      checkUpdateBtn.textContent = 'Check for Updates';
                      
                      // Update last check time
                      const lastCheckElem = document.getElementById('lastUpdateCheck');
                      if (lastCheckElem) {
                          lastCheckElem.textContent = new Date().toLocaleString();
                      }
                  });
          });
      }
      
      // Update last check time display initially
      const lastCheckElem = document.getElementById('lastUpdateCheck');
      const lastCheck = localStorage.getItem('lastUpdateCheck');
      if (lastCheckElem && lastCheck) {
          lastCheckElem.textContent = new Date(parseInt(lastCheck)).toLocaleString();
      }
    });
  </script>
</body>
</html>